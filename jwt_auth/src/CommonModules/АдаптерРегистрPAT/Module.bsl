
Функция ПолучитьPAT(Знач ИдентификаторТокена, Знач РезолверПользователей) Экспорт
	ИдентификаторТокена = НормализоватьUUID(ИдентификаторТокена, "PAT.STORE.BAD_TOKENID");
	
	Попытка
		Данные = РегистрыСведений.ПерсональныеТокеныДоступа.ПрочитатьПоИдентификатору(ИдентификаторТокена);
	Исключение
		ОшибкиПриложения.ОшибкаКонфигурации(
			"Ошибка чтения PAT из хранилища.",
			"PAT.STORE.READ_FAILED",
			Новый Структура("ИдентификаторТокена", ИдентификаторТокена),
			ИнформацияОбОшибке()
		);
	КонецПопытки;
	
	Если Данные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	UUIDПользователя = РезолверПользователей.UUIDПоСсылке(Данные.Пользователь);
	
	Рез = Новый Структура;
	Рез.Вставить("ИдентификаторТокена", Данные.ИдентификаторТокена);	
	Рез.Вставить("Пользователь", UUIDПользователя); // в домене возвращаем UUID
	
	Рез.Вставить("СольHex", НРег(Строка(Данные.СольHex)));
	Рез.Вставить("ХэшHex", НРег(Строка(Данные.ХэшHex)));
	Рез.Вставить("Алгоритм", Строка(Данные.Алгоритм));
	
	Рез.Вставить("ДействуетДо", Данные.ДействуетДо);
	Рез.Вставить("Отозван", Данные.Отозван);
	
	Рез.Вставить("Создан",  Данные.Создан);
	Рез.Вставить("ПоследнееИспользование", Данные.ПоследнееИспользование);
	Рез.Вставить("Описание", Данные.Описание);
	
	Возврат Рез;
КонецФункции

Процедура ЗафиксироватьИспользование(Знач ИдентификаторТокена, Знач ВремяUTC) Экспорт
	
	ИдентификаторТокена = НормализоватьUUID(ИдентификаторТокена, "PAT.STORE.BAD_TOKENID");

	Если ВремяUTC = Неопределено Или ТипЗнч(ВремяUTC) <> Тип("Дата") Тогда
		ОшибкиПриложения.ОшибкаИспользования(
			"Некорректное время использования PAT.",
			"PAT.STORE.BAD_LASTUSED",
			Новый Структура("ВремяUTC", ВремяUTC)
		);
	КонецЕсли;

	Попытка
		РегистрыСведений.ПерсональныеТокеныДоступа.ОбновитьПоследнееИспользование(ИдентификаторТокена, ВремяUTC);
	Исключение
		ОшибкиПриложения.ОшибкаКонфигурации(
			"Ошибка обновления последнего использования PAT.",
			"PAT.STORE.UPDATE_LASTUSED_FAILED",
			Новый Структура("ИдентификаторТокена", ИдентификаторТокена),
			ИнформацияОбОшибке()
		);
	КонецПопытки;
КонецПроцедуры

Процедура СоздатьPAT(Знач ЗаписьPAT, Знач РезолверПользователей) Экспорт
	
	ПроверитьЗаписьPAT(ЗаписьPAT);
	
	ЗаписьДляРегистра = Новый Структура;
	Для Каждого К Из ЗаписьPAT Цикл
		ЗаписьДляРегистра.Вставить(К.Ключ, К.Значение);
	КонецЦикла;

	ЗаписьДляРегистра.Пользователь = РезолверПользователей.СсылкаПоUUID(ЗаписьPAT.Пользователь);
	
	Попытка
		РегистрыСведений.ПерсональныеТокеныДоступа.Записать(ЗаписьДляРегистра);
	Исключение
		ОшибкиПриложения.ОшибкаКонфигурации(
		"Ошибка записи PAT в хранилище.",
		"PAT.STORE.WRITE_FAILED",
		Новый Структура("ИдентификаторТокена", ЗаписьPAT.ИдентификаторТокена),
		ИнформацияОбОшибке()
		);
	КонецПопытки;
КонецПроцедуры

Процедура Отозвать(Знач ИдентификаторТокена, Порты) Экспорт
	ИдентификаторТокена = НормализоватьUUID(ИдентификаторТокена, "PAT.STORE.BAD_TOKENID");

	Попытка
		РегистрыСведений.ПерсональныеТокеныДоступа.Отозвать(ИдентификаторТокена);
	Исключение
		ОшибкиПриложения.ОшибкаКонфигурации(
			"Ошибка отзыва PAT.",
			"PAT.STORE.REVOKE_FAILED",
			Новый Структура("ИдентификаторТокена", ИдентификаторТокена),
				ИнформацияОбОшибке()
		);
	КонецПопытки;
КонецПроцедуры

Процедура ПроверитьЗаписьPAT(Знач ЗаписьPAT)
	Если ЗаписьPAT = Неопределено Или ТипЗнч(ЗаписьPAT) <> Тип("Структура") Тогда
		ОшибкиПриложения.ОшибкаИспользования(
			"Запись PAT должна быть структурой.",
			"PAT.STORE.BAD_RECORD"
		);
	КонецЕсли;

	ПроверитьСвойство(ЗаписьPAT, "ИдентификаторТокена");
	ПроверитьСвойство(ЗаписьPAT, "Пользователь");
	ПроверитьСвойство(ЗаписьPAT, "ХэшHex");
	ПроверитьСвойство(ЗаписьPAT, "СольHex");
	ПроверитьСвойство(ЗаписьPAT, "Алгоритм");
	ПроверитьСвойство(ЗаписьPAT, "ДействуетДо");
	ПроверитьСвойство(ЗаписьPAT, "Отозван");
	ПроверитьСвойство(ЗаписьPAT, "Создан");
	ПроверитьСвойство(ЗаписьPAT, "Описание");
	// ПоследнееИспользование допускаем Неопределено

	ЗаписьPAT.ИдентификаторТокена = НормализоватьUUID(ЗаписьPAT.ИдентификаторТокена, "PAT.STORE.BAD_TOKENID");

	Если ТипЗнч(ЗаписьPAT.ДействуетДо) <> Тип("Дата") Тогда
		ОшибкиПриложения.ОшибкаИспользования("ДействуетДо должно быть датой.", "PAT.STORE.BAD_EXPIRES");
	КонецЕсли;

	Если ТипЗнч(ЗаписьPAT.Создан) <> Тип("Дата") Тогда
		ОшибкиПриложения.ОшибкаИспользования("Создан должно быть датой.", "PAT.STORE.BAD_CREATED");
	КонецЕсли;

	Если ЗаписьPAT.ПоследнееИспользование <> Неопределено И ТипЗнч(ЗаписьPAT.ПоследнееИспользование) <> Тип("Дата") Тогда
		ОшибкиПриложения.ОшибкаИспользования(
			"ПоследнееИспользование должно быть датой или Неопределено.",
			"PAT.STORE.BAD_LASTUSED"
		);
	КонецЕсли;

	// Hex нормализация + проверка длин
	Соль = НРег(Строка(ЗаписьPAT.СольHex));
	Хэш  = НРег(Строка(ЗаписьPAT.ХэшHex));

	Если СтрДлина(Соль) <> 32 Или НЕ PAT_Логика.ЭтоHexСтрока(Соль) Тогда
		ОшибкиПриложения.НеподдерживаемыйФормат(
			"Некорректная соль PAT (ожидается 32 hex).",
			"PAT.STORE.BAD_SALT",
			Новый Структура("СольHex", ЗаписьPAT.СольHex)
		);
	КонецЕсли;

	Если СтрДлина(Хэш) <> 64 Или НЕ PAT_Логика.ЭтоHexСтрока(Хэш) Тогда
		ОшибкиПриложения.НеподдерживаемыйФормат(
			"Некорректный хэш PAT (ожидается 64 hex).",
			"PAT.STORE.BAD_HASH",
			Новый Структура("ХэшHex", ЗаписьPAT.ХэшHex)
		);
	КонецЕсли;

	ЗаписьPAT.СольHex = Соль;
	ЗаписьPAT.ХэшHex  = Хэш;

	Если СтрДлина(СокрЛП(Строка(ЗаписьPAT.Алгоритм))) = 0 Тогда
		ОшибкиПриложения.ОшибкаИспользования("Алгоритм PAT не заполнен.", "PAT.STORE.BAD_ALGO");
	КонецЕсли;

	Если СтрДлина(СокрЛП(Строка(ЗаписьPAT.Описание))) = 0 Тогда
		ЗаписьPAT.Описание = "PAT";
	КонецЕсли;

КонецПроцедуры

Процедура ПроверитьСвойство(Знач Стр, Знач Имя)
	Если НЕ Стр.Свойство(Имя) Тогда
		ОшибкиПриложения.ОшибкаИспользования(
			"В записи PAT отсутствует обязательное поле: " + Имя,
			"PAT.STORE.MISSING_FIELD",
			Новый Структура("Поле", Имя)
		);
	КонецЕсли;
КонецПроцедуры

Функция НормализоватьUUID(Знач Значение, Знач КодОшибки)
	Если Значение = Неопределено Тогда
		ОшибкиПриложения.НеподдерживаемыйФормат("Не задан UUID.", КодОшибки);
	КонецЕсли;

	Если ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат Значение;
	КонецЕсли;

	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Попытка
			Возврат Новый УникальныйИдентификатор(Значение);
		Исключение
			ОшибкиПриложения.НеподдерживаемыйФормат(
				"Некорректный UUID.",
				КодОшибки,
				Новый Структура("Значение", Значение),
				ИнформацияОбОшибке()
			);
		КонецПопытки;
	КонецЕсли;

	ОшибкиПриложения.НеподдерживаемыйФормат(
		"Некорректный тип UUID.",
		КодОшибки,
		Новый Структура("Тип", Строка(ТипЗнч(Значение)))
	);
КонецФункции



