
Функция СанитизироватьЗначение(Знач Значение,
	Режим = "Логи",
	МаксимумУровней = 8,
	МаксимумЭлементов = 100,
	МаксимумДлинаСтроки = 8000) Экспорт
	Возврат СанитизироватьЗначениеВнутр(Значение, Режим, 0, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки);
КонецФункции


Функция СанитизироватьСтроку(Знач Текст, МаксимумДлинаСтроки = 8000) Экспорт
	Если Текст = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = ОграничитьДлинуСтроки(Строка(Текст), МаксимумДлинаСтроки);
	
	// PAT: pat.<uuid>.<secret>
	Результат = МаскироватьPAT(Результат);
	
	// Authorization: Bearer ... / Basic ...
	Результат = МаскироватьAuthorizationЗаголовки(Результат);
	
	// URL-параметры
	Результат = МаскироватьURLПараметры(Результат);
	
	// JSON-поля
	Результат = МаскироватьJSONСекретныеПоля(Результат);
	
	Возврат Результат;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Рекурсивная очистка значений
///////////////////////////////////////////////////////////////////////////////

Функция СанитизироватьЗначениеВнутр(Знач Значение,
	Режим,
	Уровень,
	МаксимумУровней,
	МаксимумЭлементов,
	МаксимумДлинаСтроки)
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Уровень >= МаксимумУровней Тогда
		// дальше не разворачиваем, чтобы не разнести лог/ответ
		Возврат "[TRUNCATED_DEPTH]";
	КонецЕсли;
	
	ТипЗ = ТипЗнч(Значение);
	
	// Простые типы
	Если ТипЗ = Тип("Строка") Тогда
		Возврат СанитизироватьСтроку(Значение, МаксимумДлинаСтроки);
		
	ИначеЕсли ТипЗ = Тип("Число")
		Или ТипЗ = Тип("Булево")
		Или ТипЗ = Тип("Дата")
		Или ТипЗ = Тип("УникальныйИдентификатор")
		Тогда
		Возврат Значение;
		
	ИначеЕсли ТипЗ = Тип("Структура") Тогда
		Возврат СанитизироватьСтруктуруВнутр(Значение, Режим, Уровень, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки);
		
	ИначеЕсли ТипЗ = Тип("Соответствие") Тогда
		Возврат СанитизироватьСоответствиеВнутр(Значение, Режим, Уровень, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки);
		
	ИначеЕсли ТипЗ = Тип("Массив") Тогда
		Возврат СанитизироватьМассивВнутр(Значение, Режим, Уровень, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки);
		
	ИначеЕсли ТипЗ = Тип("ДвоичныеДанные") Тогда
		// В логах двоичные данные не нужны
		Возврат "[BINARY]";
		
	Иначе
		// Любые прочие объекты превращаем в безопасную строку
		Попытка
			Стр = Строка(Значение);
		Исключение
			Стр = "<" + Строка(ТипЗ) + ">";
		КонецПопытки;
		
		Возврат ОграничитьДлинуСтроки(СанитизироватьСтроку(Стр, МаксимумДлинаСтроки), МаксимумДлинаСтроки);
	КонецЕсли;
	
КонецФункции


Функция СанитизироватьСтруктуруВнутр(Знач ИсхСтруктура,
	Режим,
	Уровень,
	МаксимумУровней,
	МаксимумЭлементов,
	МаксимумДлинаСтроки)
	
	Рез = Новый Структура;
	
	Счетчик = 0;
	Для Каждого Пара Из ИсхСтруктура Цикл
		Счетчик = Счетчик + 1;
		Если Счетчик > МаксимумЭлементов Тогда
			Рез.Вставить("_truncated", "[TRUNCATED_ITEMS]");
			Прервать;
		КонецЕсли;
		
		Ключ = Пара.Ключ;
		Значение = Пара.Значение;
		
		Если ЭтоЧувствительныйКлюч(Ключ) Тогда
			Рез.Вставить(Ключ, "[REDACTED]");
		Иначе
			Рез.Вставить(Ключ, СанитизироватьЗначениеВнутр(Значение, Режим, Уровень + 1, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки));
		КонецЕсли;
	КонецЦикла;
	
	Возврат Рез;
КонецФункции


Функция СанитизироватьСоответствиеВнутр(Знач ИсхСоответствие,
	Режим,
	Уровень,
	МаксимумУровней,
	МаксимумЭлементов,
	МаксимумДлинаСтроки)
	
	Рез = Новый Соответствие;
	
	Счетчик = 0;
	Для Каждого Пара Из ИсхСоответствие Цикл
		Счетчик = Счетчик + 1;
		Если Счетчик > МаксимумЭлементов Тогда
			Рез.Вставить("_truncated", "[TRUNCATED_ITEMS]");
			Прервать;
		КонецЕсли;
		
		Ключ = Пара.Ключ;
		Значение = Пара.Значение;
		
		// В соответствиях ключ может быть не строкой.
		Если ТипЗнч(Ключ) = Тип("Строка") И ЭтоЧувствительныйКлюч(Ключ) Тогда
			Рез.Вставить(Ключ, "[REDACTED]");
		Иначе
			Рез.Вставить(Ключ, СанитизироватьЗначениеВнутр(Значение, Режим, Уровень + 1, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки));
		КонецЕсли;
	КонецЦикла;
	
	Возврат Рез;
КонецФункции


Функция СанитизироватьМассивВнутр(Знач ИсхМассив,
	Режим,
	Уровень,
	МаксимумУровней,
	МаксимумЭлементов,
	МаксимумДлинаСтроки)
	
	Рез = Новый Массив;
	
	Счетчик = 0;
	Для Каждого Элемент Из ИсхМассив Цикл
		Счетчик = Счетчик + 1;
		Если Счетчик > МаксимумЭлементов Тогда
			Рез.Добавить("[TRUNCATED_ITEMS]");
			Прервать;
		КонецЕсли;
		
		Рез.Добавить(СанитизироватьЗначениеВнутр(Элемент, Режим, Уровень + 1, МаксимумУровней, МаксимумЭлементов, МаксимумДлинаСтроки));
	КонецЦикла;
	
	Возврат Рез;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Список чувствительных ключей
///////////////////////////////////////////////////////////////////////////////

Функция ЭтоЧувствительныйКлюч(Знач Ключ)
	Если Ключ = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	КлючН = НРег(Строка(Ключ));

	// Минимальный набор — расширяйте под себя
	Если КлючН = "authorization" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "token" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "access_token" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "refresh_token" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "secret" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "client_secret" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "password" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "apikey" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "api_key" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "bearer" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "basic" Тогда Возврат Истина; КонецЕсли;
	Если КлючН = "pat" Тогда Возврат Истина; КонецЕсли;

	Возврат Ложь;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Строковые маскировки (без Найти)
///////////////////////////////////////////////////////////////////////////////

Функция МаскироватьPAT(Знач Текст)
	Если Текст = "" Тогда Возврат Текст; КонецЕсли;
	
	Рез = Текст;
	Ниж = НРег(Рез);
	
	Искомое = "pat.";
	Позиция = ПозицияПодстроки(Ниж, Искомое, 1);
	
	Пока Позиция > 0 Цикл
		
		// Граница слова: перед "pat." не должно быть буквы/цифры/подчёркивания (иначе "compat." и т.п.)
		Если Позиция > 1 Тогда
			Пред = Сред(Ниж, Позиция - 1, 1);
			Если ЭтоСимволСловаASCII(Пред) Тогда
				Позиция = ПозицияПодстроки(Ниж, Искомое, Позиция + 1);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Нач = Позиция;
		Кон = Нач;
		
		Пока Кон <= СтрДлина(Рез) Цикл
			Симв = Сред(Рез, Кон, 1);
			Если ЭтоРазрешенныйСимволPAT(Симв) Тогда
				Кон = Кон + 1;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		КандидатПолный = Сред(Рез, Нач, Кон - Нач);
		
		// Уберём хвостовые точки (чтобы не ломать пунктуацию)
		Кандидат = КандидатПолный;
		ХвостТочек = "";
		Пока СтрДлина(Кандидат) > 0 Цикл
			Послед = Сред(Кандидат, СтрДлина(Кандидат), 1);
			Если Послед = "." Тогда
				ХвостТочек = ХвостТочек + ".";
				Кандидат = Лев(Кандидат, СтрДлина(Кандидат) - 1);
			Иначе
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Части = СтрРазделить(Кандидат, ".");
		
		Если Части.Количество() >= 3 Тогда
			Если НРег(Части[0]) = "pat" И ЭтоUUIDСтрока(Части[1]) Тогда
				НовыйТокен = "pat." + Части[1] + ".[REDACTED]" + ХвостТочек;
				
				Рез = Лев(Рез, Нач - 1) + НовыйТокен + Сред(Рез, Нач + СтрДлина(КандидатПолный));
				Ниж = НРег(Рез);
				
				Позиция = ПозицияПодстроки(Ниж, Искомое, Нач + СтрДлина(НовыйТокен));
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Позиция = ПозицияПодстроки(Ниж, Искомое, Нач + 1);
	КонецЦикла;
	
	Возврат Рез;
КонецФункции


Функция МаскироватьAuthorizationЗаголовки(Знач Текст)
	Если Текст = "" Тогда Возврат Текст; КонецЕсли;
	
	// CRLF -> LF
	Норм = СтрЗаменить(Текст, Символы.ВК + Символы.ПС, Символы.ПС);
	Строки = СтрРазделить(Норм, Символы.ПС);
	
	Рез = "";
	Для Инд = 0 По Строки.Количество() - 1 Цикл
		Линия = Строки[Инд];
		Линия2 = МаскироватьAuthorizationВСтроке(Линия);
		
		Если Инд > 0 Тогда
			Рез = Рез + Символы.ПС;
		КонецЕсли;
		
		Рез = Рез + Линия2;
	КонецЦикла;
	
	Возврат Рез;
КонецФункции


Функция МаскироватьAuthorizationВСтроке(Знач Линия)
	Если Линия = "" Тогда Возврат Линия; КонецЕсли;
	
	// Сохраним ведущие пробелы/таб
	П = 1;
	Пока П <= СтрДлина(Линия) Цикл
		Симв = Сред(Линия, П, 1);
		Если Симв = " " Или Симв = Символы.Таб Тогда
			П = П + 1;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ПрефиксОтступа = Лев(Линия, П - 1);
	Ост = Сред(Линия, П);
	
	ОстН = НРег(Ост);
	Если Не (Лев(ОстН, СтрДлина("authorization")) = "authorization") Тогда
		Возврат Линия;
	КонецЕсли;
	
	// Ищем ':' или '=' в Ост (без Найти)
	ПозДвоеточие = ПозицияСимвола(Ост, ":", 1);
	ПозРавно = ПозицияСимвола(Ост, "=", 1);
	
	Если ПозДвоеточие = 0 И ПозРавно = 0 Тогда
		Возврат ПрефиксОтступа + "Authorization: [REDACTED]";
	КонецЕсли;
	
	Если ПозДвоеточие = 0 Тогда
		ПозРазд = ПозРавно;
	ИначеЕсли ПозРавно = 0 Тогда
		ПозРазд = ПозДвоеточие;
	Иначе
		Если ПозДвоеточие < ПозРавно Тогда
			ПозРазд = ПозДвоеточие;
		Иначе
			ПозРазд = ПозРавно;
		КонецЕсли;
	КонецЕсли;
	
	Префикс = Лев(Ост, ПозРазд); // включая разделитель
	Хвост = СокрЛП(Сред(Ост, ПозРазд + 1));
	ХвостН = НРег(Хвост);
	
	Если Лев(ХвостН, 7) = "bearer " Тогда
		Возврат ПрефиксОтступа + Префикс + " Bearer [REDACTED]";
	ИначеЕсли Лев(ХвостН, 6) = "basic " Тогда
		Возврат ПрефиксОтступа + Префикс + " Basic [REDACTED]";
	Иначе
		Возврат ПрефиксОтступа + Префикс + " [REDACTED]";
	КонецЕсли;
КонецФункции


Функция МаскироватьURLПараметры(Знач Текст)
	Если Текст = "" Тогда Возврат Текст; КонецЕсли;
	
	Ключи = Новый Массив;
	Ключи.Добавить("token");
	Ключи.Добавить("access_token");
	Ключи.Добавить("refresh_token");
	Ключи.Добавить("secret");
	Ключи.Добавить("password");
	Ключи.Добавить("apikey");
	Ключи.Добавить("api_key");
	Ключи.Добавить("client_secret");
	Ключи.Добавить("authorization");
	
	Рез = Текст;
	Для Каждого Ключ Из Ключи Цикл
		Рез = МаскироватьОдиночныйURLПараметр(Рез, Ключ);
	КонецЦикла;
	
	Возврат Рез;
КонецФункции


Функция МаскироватьОдиночныйURLПараметр(Знач Текст, Знач Ключ)
	Если Текст = "" Тогда Возврат Текст; КонецЕсли;
	
	Ниж = НРег(Текст);
	Шаблон = НРег(Ключ) + "=";
	
	Позиция = ПозицияПодстроки(Ниж, Шаблон, 1);
	Пока Позиция > 0 Цикл
		
		// Проверим, что это реально начало параметра (либо в начале, либо после ? & пробела/переноса)
		Если Позиция > 1 Тогда
			Пред = Сред(Ниж, Позиция - 1, 1);
			Если Не (Пред = "?" Или Пред = "&" Или Пред = " " Или Пред = Символы.ПС Или Пред = Символы.ВК) Тогда
				Позиция = ПозицияПодстроки(Ниж, Шаблон, Позиция + 1);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Если НРег(Ключ) = "authorization" Тогда
			
			// Пропускаем только если это похоже на заголовок (в начале строки с отступом),
			// т.к. заголовок уже маскируется МаскироватьAuthorizationЗаголовки().
			Если ЭтоНачалоСтрокиСОтступом(Текст, Позиция) Тогда
				
				// Позиция после "authorization="
				П = Позиция + СтрДлина(Шаблон);
				
				// пропустим пробелы/таб
				Пока П <= СтрДлина(Текст) Цикл
					Симв = Сред(Текст, П, 1);
					Если Симв = " " Или Симв = Символы.Таб Тогда
						П = П + 1;
					Иначе
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				ХвостН = НРег(Сред(Текст, П));
				
				// Если уже похоже на маскированный заголовок — не трогаем второй раз
				Если Лев(ХвостН, 7) = "bearer "
					Или Лев(ХвостН, 6) = "basic "
					Или Лев(ХвостН, 10) = "[redacted]"
				Тогда
					Позиция = ПозицияПодстроки(Ниж, Шаблон, Позиция + 1);
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		СтартЗнач = Позиция + СтрДлина(Шаблон);
		Кон = СтартЗнач;
		
		Пока Кон <= СтрДлина(Текст) Цикл
			Симв = Сред(Текст, Кон, 1);
			Если Симв = "&"
				Или Симв = " "
				Или Симв = Символы.ПС
				Или Симв = Символы.ВК
				Или Симв = "#"
				Или Симв = """"
				Или Симв = "'"
				Тогда
				Прервать;
			КонецЕсли;
			Кон = Кон + 1;
		КонецЦикла;
		
		Текст = Лев(Текст, СтартЗнач - 1) + "[REDACTED]" + Сред(Текст, Кон);
		
		Ниж = НРег(Текст);
		Позиция = ПозицияПодстроки(Ниж, Шаблон, СтартЗнач + СтрДлина("[REDACTED]"));
	КонецЦикла;
	
	Возврат Текст;
КонецФункции


Функция МаскироватьJSONСекретныеПоля(Знач Текст)
	Если Текст = "" Тогда Возврат Текст; КонецЕсли;
	
	Ключи = Новый Массив;
	Ключи.Добавить("authorization");
	Ключи.Добавить("token");
	Ключи.Добавить("access_token");
	Ключи.Добавить("refresh_token");
	Ключи.Добавить("secret");
	Ключи.Добавить("password");
	Ключи.Добавить("apikey");
	Ключи.Добавить("api_key");
	Ключи.Добавить("client_secret");
	
	Рез = Текст;
	Для Каждого Ключ Из Ключи Цикл
		Рез = МаскироватьJSONКлюч(Рез, Ключ);
	КонецЦикла;
	
	Возврат Рез;
КонецФункции


Функция МаскироватьJSONКлюч(Знач Текст, Знач Ключ)
	Если Текст = "" Тогда Возврат Текст; КонецЕсли;
	
	Ниж = НРег(Текст);
	Искомое = """" + НРег(Ключ) + """"; // "key"
	
	Позиция = ПозицияПодстроки(Ниж, Искомое, 1);
	Пока Позиция > 0 Цикл
		
		ПослеКлюча = Позиция + СтрДлина(Искомое);
		
		// Найдём двоеточие после ключа
		ПозДвоеточие = ПозицияСимвола(Текст, ":", ПослеКлюча);
		Если ПозДвоеточие = 0 Тогда
			Позиция = ПозицияПодстроки(Ниж, Искомое, ПослеКлюча);
			Продолжить;
		КонецЕсли;
		
		// пропустим пробелы/таб
		П = ПозДвоеточие + 1;
		Пока П <= СтрДлина(Текст) Цикл
			Симв = Сред(Текст, П, 1);
			Если Симв = " " Или Симв = Символы.Таб Тогда
				П = П + 1;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		// Маскируем только строковые значения "..."
		Если П <= СтрДлина(Текст) И Сред(Текст, П, 1) = """" Тогда
			НачЗнач = П + 1;
			ПозЗакр = НайтиЗакрывающуюКавычкуJSON(Текст, НачЗнач);
			Если ПозЗакр > 0 Тогда
				Текст = Лев(Текст, НачЗнач - 1) + "[REDACTED]" + Сред(Текст, ПозЗакр);
				Ниж = НРег(Текст);
				
				Позиция = ПозицияПодстроки(Ниж, Искомое, НачЗнач + СтрДлина("[REDACTED]"));
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Позиция = ПозицияПодстроки(Ниж, Искомое, ПослеКлюча);
	КонецЦикла;
	
	Возврат Текст;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Вспомогательные функции (поиск без Найти)
///////////////////////////////////////////////////////////////////////////////

Функция ПозицияПодстроки(Знач СтрокаГде, Знач ПодстрокаЧто, Знач НачальнаяПозиция = 1)
	// Возвращает позицию (1..N) или 0
	Если СтрокаГде = "" Или ПодстрокаЧто = "" Тогда
		Возврат 0;
	КонецЕсли;
	
	Дл = СтрДлина(СтрокаГде);
	ДлП = СтрДлина(ПодстрокаЧто);
	
	Если НачальнаяПозиция < 1 Тогда НачальнаяПозиция = 1; КонецЕсли;
	Если ДлП > Дл Тогда Возврат 0; КонецЕсли;
	
	Макс = Дл - ДлП + 1;
	
	Для П = НачальнаяПозиция По Макс Цикл
		Если Сред(СтрокаГде, П, ДлП) = ПодстрокаЧто Тогда
			Возврат П;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
КонецФункции


Функция ПозицияСимвола(Знач СтрокаГде, Знач СимволЧто, Знач НачальнаяПозиция = 1)
	Если СтрокаГде = "" Тогда Возврат 0; КонецЕсли;
	Если НачальнаяПозиция < 1 Тогда НачальнаяПозиция = 1; КонецЕсли;
	
	Для П = НачальнаяПозиция По СтрДлина(СтрокаГде) Цикл
		Если Сред(СтрокаГде, П, 1) = СимволЧто Тогда
			Возврат П;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
КонецФункции


Функция НайтиЗакрывающуюКавычкуJSON(Знач Текст, Знач ПозицияСимвола)
	// Ищем следующую " которая НЕ экранирована нечётным числом \ перед ней
	П = ПозицияСимвола;
	Пока П <= СтрДлина(Текст) Цикл
		Если Сред(Текст, П, 1) = """" Тогда
			КолСлэшей = 0;
			К = П - 1;
			Пока К >= 1 И Сред(Текст, К, 1) = "\" Цикл
				КолСлэшей = КолСлэшей + 1;
				К = К - 1;
			КонецЦикла;
			
			Если (КолСлэшей % 2) = 0 Тогда
				Возврат П;
			КонецЕсли;
		КонецЕсли;
		П = П + 1;
	КонецЦикла;
	
	Возврат 0;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Прочие хелперы
///////////////////////////////////////////////////////////////////////////////

Функция ОграничитьДлинуСтроки(Знач Текст, Знач МаксДлина)
	Если МаксДлина <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Если СтрДлина(Текст) <= МаксДлина Тогда
		Возврат Текст;
	КонецЕсли;
	
	// оставим хвост-метку, чтобы было видно что обрезали
	Возврат Лев(Текст, МаксДлина) + "...[TRUNCATED]";
КонецФункции


Функция ЭтоРазрешенныйСимволPAT(Знач Симв)
	С = НРег(Симв);
	Возврат ПозицияПодстроки("abcdefghijklmnopqrstuvwxyz0123456789-_.", С, 1) > 0;
КонецФункции


Функция ЭтоСимволСловаASCII(Знач Симв)
	С = НРег(Симв);
	Возврат ПозицияПодстроки("abcdefghijklmnopqrstuvwxyz0123456789_", С, 1) > 0;
КонецФункции


Функция ЭтоUUIDСтрока(Знач СтрUUID)
	Попытка
		Лок = Новый УникальныйИдентификатор(СтрUUID);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

Функция ЭтоНачалоСтрокиСОтступом(Знач Текст, Знач ПозицияНачала)
	// true если слева до начала строки/переноса только пробелы/таб
	Если ПозицияНачала <= 1 Тогда
		Возврат Истина;
	КонецЕсли;
	
	К = ПозицияНачала - 1;
	Пока К >= 1 Цикл
		Симв = Сред(Текст, К, 1);
		
		Если Симв = Символы.ПС Или Симв = Символы.ВК Тогда
			Возврат Истина;
		КонецЕсли;
		
		Если Симв = " " Или Симв = Символы.Таб Тогда
			К = К - 1;
			Продолжить;
		КонецЕсли;
		
		Возврат Ложь;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции