
// Без I/O: только разбор формата PAT.

Функция РазобратьPAT(Знач СтрокаPAT) Экспорт
	СтрокаPAT = СокрЛП(СтрокаPAT);
	Если СтрДлина(СтрокаPAT) = 0 Тогда
		ВызватьИсключение "Не авторизован: пустой PAT.";
	КонецЕсли;
	
	// Ожидаем: pat.<uuid>.<secret>
	Части = СтрРазделить(СтрокаPAT, ".", Истина);
	Если Части.Количество() <> 3 Тогда
		ВызватьИсключение "Не авторизован: некорректный формат PAT.";
	КонецЕсли;
	
	Если НРег(СокрЛП(Части[0])) <> "pat" Тогда
		ВызватьИсключение "Не авторизован: некорректный префикс PAT.";
	КонецЕсли;
	
	СтрUUID = СокрЛП(Части[1]);
	Secret = НРег(СокрЛП(Части[2]));
	
	Если СтрДлина(СтрUUID) = 0 Тогда
		ВызватьИсключение "Не авторизован: отсутствует идентификатор PAT.";
	КонецЕсли;
	
	Если СтрДлина(Secret) = 0 Тогда
		ВызватьИсключение "Не авторизован: отсутствует секрет PAT.";
	КонецЕсли;
	
	// UUID -> УникальныйИдентификатор
	Попытка
		ИдентификаторТокена = Новый УникальныйИдентификатор(СтрUUID);
	Исключение
		ВызватьИсключение "Не авторизован: идентификатор PAT не является UUID.";
	КонецПопытки;
	
	// Секрет: hex-строка, lower-case
	Если Не ЭтоHexСтрока(Secret) Тогда
		ВызватьИсключение "Не авторизован: секрет PAT должен быть hex-строкой.";
	КонецЕсли;
	
	Возврат Новый Структура("ИдентификаторТокена,Secret", ИдентификаторТокена, Secret);
КонецФункции

Функция ЭтоHexСтрока(Знач Стр) Экспорт
	Стр = НРег(Стр);
	Если СтрДлина(Стр) = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для i = 1 По СтрДлина(Стр) Цикл
		С = Сред(Стр, i, 1);
		Если (С < "0" Или С > "9") И (С < "a" Или С > "f") Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции